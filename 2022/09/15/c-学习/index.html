<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="c++学习, AKYCCCC">
    <meta name="description" content="C++从键盘输入，和打印.c++要包含头文件#include&amp;lt;iostream&amp;gt;
和C语言一样C++可以使用scanf()和printf()输入输出
c++有新的输入输出.
#include&amp;lt;iostream&amp;gt;
&amp;#">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>c++学习 | AKYCCCC</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">AKYCCCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">AKYCCCC</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">c++学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/cPlusPlus%E5%AD%A6%E4%B9%A0/">
                                <span class="chip bg-color">cPlusPlus学习</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/cPlusPlus/" class="post-category">
                                cPlusPlus
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-09-15
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="C-从键盘输入，和打印"><a href="#C-从键盘输入，和打印" class="headerlink" title="C++从键盘输入，和打印."></a>C++从键盘输入，和打印.</h2><p>c++要包含头文件<code>#include&lt;iostream&gt;</code></p>
<p>和C语言一样C++可以使用<code>scanf()</code>和<code>printf()</code>输入输出</p>
<p>c++有新的输入输出.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
&#x2F;&#x2F;使用cout和cin输入输出要使用命名空间
using namespace std;
int main()
&#123;
    int num &#x3D; 0;
    cin&gt;&gt;num;
    cout&lt;&lt;num&lt;&lt;endl;
    &#x2F;&#x2F;不在上面写命名空间可以这样写
    std::cin&gt;&gt;num;
    std::cout&lt;&lt;num&lt;&lt;std::endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="c-内存区域的划分"><a href="#c-内存区域的划分" class="headerlink" title="c++内存区域的划分"></a>c++内存区域的划分</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈存放局部变量，函数的形参，</p>
<p>程序结束由系统自动释放内存.</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>使用new，创建的数据存放在堆区</p>
<p>实例化的对象，存放在堆区</p>
<p>需要程序员手动释放</p>
<p>不释放会造成内存泄露</p>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>代码区是共享的</p>
<p>存放代码，只读.不管程序会运行几次，只有一份.</p>
<p>存放函数体的二进制代码，由操作系统管理</p>
<p>程序编译后，生成.exe可执行程序，在未执行前分成2个区域，代码区和全局区</p>
<h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><p>全局变量和静态变量（static）存放在全局区</p>
<p>全局区还包含常量区，字符常量等其他常量</p>
<p>全局区在程序结束后由操作系统释放</p>
<h3 id="const修饰的局部变量、常量、字符串常量等"><a href="#const修饰的局部变量、常量、字符串常量等" class="headerlink" title="const修饰的局部变量、常量、字符串常量等"></a>const修饰的局部变量、常量、字符串常量等</h3><p>const只会让数据能不能修改，不会改变各种数据存放的位置.</p>
<p>原来存在哪个区被const修饰后还在哪个区</p>
<h2 id="new的使用"><a href="#new的使用" class="headerlink" title="new的使用"></a>new的使用</h2><p>c++使用new操作符在堆区开辟内存</p>
<p>使用delete释放</p>
<p>（动态内存开辟如malloc等开辟的用free释放）</p>
<p>new和delete总是成对出现.</p>
<p>用完就释放，避免造成内存泄露</p>
<p>也记得将指针置为NULL，否则会造成野指针</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;new的返回值是对应数据类型的指针
int *p &#x3D; new int(10);
delete p;
p &#x3D;&#x3D; NULL;

int *arr &#x3D; new int[10];
delete[] arr;
arr &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;数据类型 &amp;变量名 &#x3D; 变量名
int a &#x3D; 0;
int &amp;b &#x3D; a;
&#x2F;&#x2F;修改b会改变a的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>引用可以当做给另一个变量取别名</p>
<p>引用需要一个合法的内存空间，意思就是数据需要在栈或者堆上。在常量区的不行.</p>
<h3 id="引用的底层"><a href="#引用的底层" class="headerlink" title="引用的底层"></a>引用的底层</h3><p>引用和指针是有区别的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 0;
int &amp;b &#x3D; a;&#x2F;&#x2F;底层是int* const b &#x3D; &amp;a;
int *c &#x3D; &amp;a;
cout&lt;&lt;&amp;c&lt;&lt;endl;&#x2F;&#x2F;1
cout&lt;&lt;&amp;a&lt;&lt;endl;&#x2F;&#x2F;2
cout&lt;&lt;&amp;a&lt;&lt;endl;&#x2F;&#x2F;3
&#x2F;&#x2F;2和3的地址相同
&#x2F;&#x2F;引用不会新开辟内存.
&#x2F;&#x2F;引用相当于a和b是同一块内存
&#x2F;&#x2F;而指针是，用一块新的内存，存了a的地址.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>对于引用，不用过多的对他怎么实现的下功夫，会熟练使用就行.</p>
<p>引用本身不开辟新的空间，但是<code>sizeof()</code>计算的时候是4，因为引用和变量用的是同一块地址.</p>
</blockquote>
<h3 id="对常量进行引用"><a href="#对常量进行引用" class="headerlink" title="对常量进行引用"></a>对常量进行引用</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int &amp;a &#x3D; 100;
&#x2F;&#x2F;底层是编译器会创建一个临时变量存放常量.然后在对其取地址
&#x2F;&#x2F;int tmp &#x3D; 100;
&#x2F;&#x2F;int* const a &#x3D; &amp;tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><p>引用在创建的时候必须初始化</p>
<p>创建好的引用的值可以改变，引用不可以改变.（引用在底层被const修饰了）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 0;
int c &#x3D; 50;
int &amp;b &#x3D; a;
b &#x3D; 100;&#x2F;&#x2F;可以改变值
b &#x3D; c;&#x2F;&#x2F;改变的是值,这里的底层是*b &#x3D; c;*b &#x3D; 50;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h3><p>函数传参分成值传递和地址传递</p>
<p>当引用作为函数参数时，就是地址传递</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(int &amp;a,int &amp;b)
&#123;
    tnp &#x3D; a;
    a &#x3D; b;
    b &#x3D; tnp;
&#125;

int main()
&#123;
    int a &#x3D; 10;
    int b &#x3D; 20;
    func(a,b);&#x2F;&#x2F;会改变a和b的值
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h3><h4 id="不要返回局部变量的引用"><a href="#不要返回局部变量的引用" class="headerlink" title="不要返回局部变量的引用"></a>不要返回局部变量的引用</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int&amp; func()
&#123;
    &#x2F;&#x2F;a是func里的局部变量，函数执行结束就会被释放
    int a &#x3D; 0;
    &#x2F;&#x2F;静态变量就可以作为返回值
    static b &#x3D; 100;
    return a;
&#125;

int main()
&#123;
    int &amp;ret &#x3D; func();
    &#x2F;&#x2F;第一次打印是因为编译器的原因，编译器会保留一次a的值
    &#x2F;&#x2F;其实a在func函数结束时就已经变成随机值了.
    cout&lt;&lt;ret&lt;&lt;endl;&#x2F;&#x2F;第一次是会打印a的值0
    cout&lt;&lt;ret&lt;&lt;endl;&#x2F;&#x2F;第二次就是随机值了
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数的调用可以作为左值"><a href="#函数的调用可以作为左值" class="headerlink" title="函数的调用可以作为左值"></a>函数的调用可以作为左值</h4><p>什么是左值？</p>
<p>粗俗的认为在“&#x3D;”左边的就是左值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数返回值是引用
int&amp; func()
&#123;
    &#x2F;&#x2F;变量是静态的
	static int a &#x3D; 500;
    return a;
&#125;

int main()
&#123;
    &#x2F;&#x2F;正常调用
    int &amp;ret &#x3D; func();
    cout&lt;&lt;ret&lt;&lt;endl;&#x2F;&#x2F;打印500
    ret &#x3D; 300; 
    cout&lt;&lt;ret&lt;&lt;endl;&#x2F;&#x2F;打印300
    &#x2F;&#x2F;作为左值调用
    func() &#x3D; 100;
    count&lt;&lt;ret&lt;&lt;endl;&#x2F;&#x2F;打印100；
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为函数<code>func()</code>的返回值是<code>int&amp;</code></p>
<p>那么<code>func() = 100;</code>是不是可以变成 <code>a = 100</code>.a是一个引用类型（int&amp;）的变量.</p>
<p>而上面<code>int &amp;ret = func();</code>是不是可以看成<code>int &amp;ret = a;</code></p>
<p>最后的结果就是ret是a的别名，ret和静态变量a的地址是同一块.</p>
<p>当函数作为左值并被赋值后，那a&#x3D;100，所以ret也变成了100</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;当出现第一个参数为默认参数时，后面的参数也必须有默认参数
&#x2F;&#x2F;在形参中直接赋值，就是函数默认参数.、
void func(int a,int b &#x3D; 10,int c &#x3D; 20)
&#123;
    ;
&#125;
int main()
&#123;
    func(10);&#x2F;&#x2F;传参时，如果没写后面的参数，就适用默认参数
    func(10,30);&#x2F;&#x2F;传参时，如果写了，就优先用写的参数值.
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意点：如果在函数声明中有默认参数，那么函数定义中就不能有默认参数.</p>
<p>反过来也一样.</p>
</blockquote>
<h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数定义形参中不写变量名，只写数据类型，就是函数占位参数
&#x2F;&#x2F;在函数传参时，需要填写对应的数据类型的值，虽然填了是不起作用的。
void func(int a,int,int)
&#123;
    ;
&#125;
int main()
&#123;
    func(10);&#x2F;&#x2F;报错，占位参数的位置没参.
    
    &#x2F;&#x2F;虽然后面的20和30其实没什么用，但是函数定义中有占位参数.所以就要填
    func(10,20,30);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>要求：</p>
<p>1.同一个作用域中</p>
<p>2.函数名称和返回值相同</p>
<p>3.函数形参的数据类型、形参个数、形参顺序不同.</p>
<h4 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h4><p> 在使用引用作为参数或者，使用函数默认参数的时候，注意不要出现二议性.</p>
<p>什么是二义性？</p>
<p>在函数重载定义的时候没报错</p>
<p>但是调用函数的时候，重载的两个函数甚至三个都可以被调用.编译器不知到该调用哪个.</p>
<p>比如<code>void func(int a)</code>和<code>void func(int a, int b = 10)</code>和<code>void func(const int &amp;a)</code></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的意义：</p>
<ul>
<li>将某一事物的属性和行为作为一个整体.来表现事物</li>
<li>将封装起来的属性和行为加以权限控制</li>
</ul>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ol>
<li>public：公共权限，类内可以访问，类外可以访问</li>
<li>protected：保护权限，类内可以访问，类外不可以访问，继承的子类可以访问</li>
<li>private：私有权限，类内可以访问， 类外不可以访问，继承的子类不可以访问</li>
</ol>
<blockquote>
<p>c++中没有default这个权限，java有.</p>
<p>C语言没有类和对象这个概念.</p>
</blockquote>
<h4 id="结构体（struct）和类（class）的区别"><a href="#结构体（struct）和类（class）的区别" class="headerlink" title="结构体（struct）和类（class）的区别"></a>结构体（struct）和类（class）的区别</h4><p>访问权限不同</p>
<p>struct默认是公共权限（public）</p>
<p>class默认是私有权限（private）</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>基本语法：</p>
<ul>
<li>没有返回值</li>
<li>函数名和类名完全相等</li>
<li>只会在调用对象的时候，调用一次.</li>
<li>系统自动调用.</li>
<li>有参数列表，可以发生重载</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>基本语法：</p>
<ul>
<li>在构造函数前面写一个’~‘，就是析构函数</li>
<li>没有返回值</li>
<li>对象销毁前会调用析构函数，系统自动调用，只会调用一次.</li>
<li>没有参数列表，不可以重载.</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>理解为有参构造函数.</p>
<p>就是构造函数的形参是自己类的引用，然后在构造函数里将传入的类的属性赋值给自己的类属性.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;
public:
    &#x2F;&#x2F;构造函数,构造函数可以重载
    Person() &#123;
        ;
    &#125;
    &#x2F;&#x2F;析构函数:不能有形参.
    ~Person() &#123;
        ;
    &#125;
    &#x2F;&#x2F;拷贝构造函数:就是构造函数的重载
    &#x2F;&#x2F;因为只是拷贝，所以用const修饰传进来的参
    &#x2F;&#x2F;拷贝构造函数要用传引用的方式传进来，所以是&amp;p.为什么以后在讲
    Person(const Person &amp;p) &#123;
        &#x2F;&#x2F;类中，类的成员前面默认带一个this指针
        &#x2F;&#x2F;也就是this-&gt;age &#x3D; p.age;
        age &#x3D; p.age;
    &#125;
    
    
    int age;
&#125;;
int main()
&#123;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><h3 id="构造、析构、拷贝构造的调用"><a href="#构造、析构、拷贝构造的调用" class="headerlink" title="构造、析构、拷贝构造的调用"></a>构造、析构、拷贝构造的调用</h3><p><em><strong>例子中的Person对应的是上面创建的Person</strong></em></p>
<p>1.括号法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person p1;&#x2F;&#x2F;默认构造函数
Person p2(10);&#x2F;&#x2F;有参构造函数
Person p3(p2);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意：在调用默认构造函数实例化对象的时候不要加括号.不然编译器会理解成这是函数声明</p>
<p>例：<code>Person p1();</code>编译器理解成函数声明，而不是实例化对象.</p>
</blockquote>
<p>2.显示法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person p1 &#x3D; Person();&#x2F;&#x2F;默认构造函数
Person p2 &#x3D; Person(10);&#x2F;&#x2F;有参构造函数
Person p3 &#x3D; Person(p2);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>3.隐式转换法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person p1 &#x3D; 10;&#x2F;&#x2F;相当于写了Person p1 &#x3D; Person(10);
Person p2 &#x3D; p4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>底层就是编译器自动帮你写成显示法了</p>
<h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h3><p>1.使用已经创建完毕的对象来初始化一个新对象</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person p1;&#x2F;&#x2F;先创建一个对象
Person p2(p1);&#x2F;&#x2F;调用拷贝构造函数创建另一个对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>2.值传递的方式给函数参数传值</p>
<p>因为函数传参的本质是，将main中传入的参数拷贝一份到形参.</p>
<p>所以当类作为函数参数的时候就会调用拷贝构造函数.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这里的p不是p1本身，而是拷贝的一份p1的数据.
void func(Person p)
&#123;
    ;
&#125;
int main()
&#123;
    Person p1;
    func(p1);&#x2F;&#x2F;调研拷贝构造函数
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.值方式返回局部对象</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person func()
&#123;
    Person p1;&#x2F;&#x2F;调用默认构造函数
    return p1;&#x2F;&#x2F;当函数返回时，这里创建的p1会被析构函数结束掉
&#125;
int main()
&#123;	
    &#x2F;&#x2F;这段代码其实可以变成：Person p1 &#x3D; p1;
    &#x2F;&#x2F;这样就相当于隐式转换法创建了一个新的p1
    Person p1 &#x3D; func();&#x2F;&#x2F;调用拷贝构造函数
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person(10);&#x2F;&#x2F;匿名对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>特点：当前行执行结束，系统会回收掉匿名对象</p>
<blockquote>
<p>注意：不要使用拷贝构造函数，初始化匿名对象</p>
<p>因为编译器会将<code>Person(p2);</code>解读为<code>Person p2;</code></p>
<p>而p2是在上面已经定义过一次了.编译器会报错p2重定义</p>
</blockquote>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：编译器提供的各种拷贝方法基本都是浅拷贝.</p>
<p>比如类中的，默认拷贝构造函数就是浅拷贝</p>
<p>什么是浅拷贝？</p>
<p>浅拷贝就是简单的把数据复制一份.</p>
<p>什么是深拷贝？</p>
<p>深拷贝在堆区申请新的空间再把数据复制过去.</p>
<hr>
<p>深拷贝和浅拷贝有什么区别？</p>
<p>当进行普通简单的变量拷贝的时候，没什么太大区别.</p>
<p>但是，当进行和指针相关的数据拷贝的时候就有问题了</p>
<p>浅拷贝，在拷贝指针类型数据的时候，只会把指针里存的地址拷贝过去.</p>
<p>假设原来的叫p1，拷贝过去的叫p2.</p>
<p>那么p1里指针的指向和p2里指针的指向是同一块内存.</p>
<p>当p1被调用完后，p1申请的内存会被释放.p2就变成了野指针.</p>
<p>深拷贝，在拷贝的时候，会在堆区申请新的一块空间.然后把p1中指针指向的值放到新的空间中，在将新空间的地址赋值给p2</p>
<p>这样当p1被释放后，p2任然是存在的.</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>作用是直接对类中的属性赋值</p>
<p>语法：<code>构造函数():成员属性名1(值)，成员属性名2(值),成员属性名3(值)，......</code>{}</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;
    
public:
    &#x2F;&#x2F;构造函数
    Person():a(10),b(20),c(30)
    &#123;
        ;
    &#125;
    &#x2F;&#x2F;另一种方式
    Person(int a,int b,int c):a(a),b(b),c(c)
    &#123;
        ;
    &#125;
    &#x2F;&#x2F;成员属性a,b,c
    int a;
    int b;
    int c;
&#125;
int main()
&#123;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类成员作为类对象"><a href="#类成员作为类对象" class="headerlink" title="类成员作为类对象"></a>类成员作为类对象</h3><p>一个类可以作为另一个类的成员</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
    ;
&#125;
class B&#123;
    A a1;&#x2F;&#x2F;A类作为B类的成员
&#125;
int main()
&#123;
    B b1;&#x2F;&#x2F;当实例化对象时，会优先构造成员类
    &#x2F;*
     调用过程是：
     A的构造;
     B的构造;
     B的析构;
     A的析构;
     
    *&#x2F;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>先构造类内的，在构造自己</p>
<p>先析构自己，在析构类内的.</p>
</blockquote>
<h3 id="类中静态成员"><a href="#类中静态成员" class="headerlink" title="类中静态成员"></a>类中静态成员</h3><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>1.静态成员变量在编译时分配内存.</p>
<ul>
<li><p>编译时分配内存的有全局区和代码区.</p>
</li>
<li><p>静态变量存在全局区、静态区.</p>
</li>
</ul>
<p>2.所有对象共享同一块数据</p>
<p>3.在类中写静态成员变量要类内声明，类外初始化</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
public:
    &#x2F;&#x2F;static int a &#x3D; 10;&#x2F;&#x2F;静态变量直接在类内初识化不行
    
    static int a;&#x2F;&#x2F;只能先声明
&#125;;
int A::a &#x3D; 10;&#x2F;&#x2F;在类外初始化，并标注这个a是类A的

int main()
&#123;
    &#x2F;&#x2F;当静态成员变量是private时，类外是不能访问
    
    &#x2F;&#x2F;调用方式1：通过对象访问
    cout&lt;&lt;A.a&lt;&lt;endl;
    &#x2F;&#x2F;调用方式2：通过类名访问
    cout&lt;&lt;A::a&lt;&lt;endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>对类中的函数用static修饰就是静态成员函数</p>
<ul>
<li><p>静态成员函数可以在类中实现，静态成员函数中只能使用静态的成员变量.</p>
</li>
<li><p>所有类共享静态成员函数</p>
</li>
<li><p>通过对象访问 <code>先实例化对象，然后.函数名（）</code></p>
</li>
<li><p>通过类名访问 <code>类名::静态函数名（）</code></p>
</li>
<li><p>静态成员函数中只能使用静态成员变量.</p>
</li>
<li><p>静态成员函数也有访问权限</p>
</li>
</ul>
<h3 id="类所占内存空间大小"><a href="#类所占内存空间大小" class="headerlink" title="类所占内存空间大小"></a>类所占内存空间大小</h3><p>空类占一个字节.</p>
<p>除了非静态成员变量</p>
<p>其他的都不算在类所占内存大小.</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this本质是一个指针</p>
<p>this指向自己类中的成员属性、成员函数.（默认的，没写也是指向的）</p>
<p>this不需要定义，直接使用.</p>
<p>在类的非静态成员函数可以用<code>return *this</code>返回对象本身.</p>
<h4 id="this的主要作用"><a href="#this的主要作用" class="headerlink" title="this的主要作用"></a>this的主要作用</h4><p>1.解决名称冲突</p>
<p>当类的成员函数的参数和类中成员属性同名的时候，可以加以区分</p>
<p>2.可以在类的非静态成员函数中返回对象本身，<code>return *this;</code></p>
<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
public:
    void func1()
    &#123;
        ;
    &#125;
    void func2()
    &#123;
        num &#x3D; 10;
    &#125;
    int num;
&#125;;
int main()
&#123;
    A *a &#x3D; NULL;
    a-&gt;func1();&#x2F;&#x2F;正常运行
    
    a-&gt;func2();&#x2F;&#x2F;出错，原因：用空指针访问类内成员
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用func2出错了，因为其实在func2中的<code>num = 10</code>;其实是<code>this-&gt;num = 10;</code></p>
<p>而a是一个空指针.用一个空指针去访问所以就报错了.</p>
<h3 id="const修饰类、成员函数-mutable"><a href="#const修饰类、成员函数-mutable" class="headerlink" title="const修饰类、成员函数(mutable)"></a>const修饰类、成员函数(mutable)</h3><h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
public:
    &#x2F;&#x2F;成员函数
    void func() const
    &#123;
        &#x2F;&#x2F;this指针的本质是指针常量，是&#96;类名 * const this;&#96;
        &#x2F;&#x2F;指针常量：指针指向不可以修改.指针指向的值可以修改
        
        num1 &#x3D; 10;&#x2F;&#x2F;错误，加上const后函数内的变量不允许修改
        num2 &#x3D; 20;&#x2F;&#x2F;可以修改，如果想让常函数中的变量可以修改，在创建变量前面加mutable修饰
    &#125;
    int num1;
    mutable int num2;
&#125;;
int main()
&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="const修饰对象"><a href="#const修饰对象" class="headerlink" title="const修饰对象"></a>const修饰对象</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    consr Person p;&#x2F;&#x2F;在对象前面加const，变成常对象
    p.num1 &#x3D; 10;&#x2F;&#x2F;常对象中的变量不可以修改
    p.num2 &#x3D; 20；&#x2F;&#x2F;被mutable修饰过的常对象中的变量可以修改
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="友元函数（friend）"><a href="#友元函数（friend）" class="headerlink" title="友元函数（friend）"></a>友元函数（friend）</h3><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Building &#123;
public:
	friend void visit(Building&amp; building);
	&#x2F;&#x2F;构造函数
	Building()
	&#123;
		b_BedRoom &#x3D; &quot;卧室&quot;;
		b_SittingRoom &#x3D; &quot;客厅&quot;;
	&#125;

	string b_SittingRoom;&#x2F;&#x2F;客厅

private:
	string b_BedRoom;&#x2F;&#x2F;卧室
&#125;;
&#x2F;&#x2F;全局函数访问
void visit(Building &amp;building)
&#123;
	cout &lt;&lt; &quot;基友访问&quot; &lt;&lt; building.b_SittingRoom &lt;&lt; endl;
	&#x2F;&#x2F;在建筑物类中申明该函数并用friend修饰，就可以访问private权限的属性
	cout &lt;&lt; &quot;基友访问&quot; &lt;&lt; building.b_BedRoom &lt;&lt; endl;
&#125;

int main()
&#123;
	Building building;
	visit(building);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Building;
class GoodGay &#123;
public:
	&#x2F;&#x2F;类内声明，类外实现构造函数
	GoodGay();
	&#x2F;&#x2F;类内声明，类外实现
	void visit();&#x2F;&#x2F;用来访问Building类中的属性
	&#x2F;&#x2F;建筑物指针
	Building *building;
	
&#125;;
&#x2F;&#x2F;建筑物类
class Building &#123;
public:
    &#x2F;&#x2F;在Building中声明友元，GoodGay的成员函数就可以访问Building中的私有成员属性
	friend class GoodGay;

	&#x2F;&#x2F;类内声明构造函数，类外实现
	Building();
	
	string b_SittingRoom;&#x2F;&#x2F;客厅

private:
	string b_BedRoom;&#x2F;&#x2F;卧室
&#125;;
&#x2F;&#x2F;类外实现构造函数
Building::Building()
&#123;
	b_BedRoom &#x3D; &quot;卧室&quot;;
	b_SittingRoom &#x3D; &quot;客厅&quot;;
&#125;
&#x2F;&#x2F;基友构造函数
GoodGay::GoodGay()
&#123;
	&#x2F;&#x2F;在基友类中创建一个建筑物类
	building &#x3D; new Building;
&#125;
&#x2F;&#x2F;类外实现类内函数
void GoodGay::visit()
&#123;
	cout &lt;&lt; building-&gt;b_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; building-&gt;b_BedRoom &lt;&lt; endl;
&#125;

int main()
&#123;
	GoodGay gg;
	gg.visit();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;在Building类里声明GoodGay类中的一个函数是友元函数
&#x2F;&#x2F;GoodGay类中被声明的那个函数就可以访问Building中的私有成员    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="运算符重载operator"><a href="#运算符重载operator" class="headerlink" title="运算符重载operator"></a>运算符重载operator</h3><h4 id="号运算符重载"><a href="#号运算符重载" class="headerlink" title="+ 号运算符重载"></a>+ 号运算符重载</h4><h5 id="成员函数重载"><a href="#成员函数重载" class="headerlink" title="成员函数重载"></a>成员函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
	&#x2F;&#x2F;通过成员函数重载运算符
	Person operator+(Person&amp; p)
	&#123;
		Person tmp;
		tmp.age &#x3D; this-&gt;age + p.age;
		return tmp;
	&#125;
	&#x2F;*
	在外面调用的本质是：p3 &#x3D; p1.operator+(p2);
	被简化成了：p3 &#x3D; p1 + p2; 
	*&#x2F;
&#125;;
int main()
&#123;
	&#x2F;&#x2F;实例化对象
	Person p1, p2,p3;
	p1.age &#x3D; 10;
	p2.age &#x3D; 20;
	p3 &#x3D; p1 + p2;
	cout &lt;&lt; p3.age &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="全局函数重载"><a href="#全局函数重载" class="headerlink" title="全局函数重载"></a>全局函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;通过全局函数重载运算符
Person operator+(Person&amp; p1, Person&amp; p2)
&#123;
	Person tmp;
	tmp.age &#x3D; p1.age + p2.age;
	return tmp;
    &#x2F;*
    在外面调用的本质是：p3 &#x3D; operator(p1,p2);
    被简化成:p3 &#x3D; p1 + p2;
    *&#x2F;
&#125;
int main()
&#123;
	&#x2F;&#x2F;实例化对象
	Person p1, p2,p3;
	p1.age &#x3D; 10;
	p2.age &#x3D; 20;
	p3 &#x3D; p1 + p2;
	cout &lt;&lt; p3.age &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="左移运算符（-lt-lt-）重载"><a href="#左移运算符（-lt-lt-）重载" class="headerlink" title="左移运算符（&lt;&lt;）重载"></a>左移运算符（&lt;&lt;）重载</h4><p>作用是打印自定义类型的数据</p>
<p>用全局函数重载左移运算符，不用成员函数重载</p>
<h5 id="成员函数重载-1"><a href="#成员函数重载-1" class="headerlink" title="成员函数重载"></a>成员函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用成员函数重载会变成：p.operator&lt;&lt;(cout)
&#x2F;&#x2F;简化为:p &lt;&lt; cout;
&#x2F;&#x2F;无法使p在右边
&#x2F;&#x2F;所以一般不使用成员函数重载左移运算符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="全局函数重载-1"><a href="#全局函数重载-1" class="headerlink" title="全局函数重载"></a>全局函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
&#125;;
&#x2F;&#x2F;通过&quot;转到定义&quot;可以知道cout是ostream类型的
&#x2F;&#x2F;因为cout对象只能有一个，所以要传引用
&#x2F;&#x2F;现在这么写的重载符号只可以输出一个，想要连续输入要改返回值
&#x2F;&#x2F;void operator&lt;&lt;(ostream &amp;cout, Person &amp;p)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	cout &lt;&lt; p.age &lt;&lt; endl;
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;下面的就可以通过链式访问来一次输出多个
ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)
&#123;
	cout &lt;&lt; p.age &lt;&lt; endl;
	return cout;
&#125;
&#x2F;&#x2F;当类的成员是private的时候，可以将全局函数做友元.
int main()
&#123;
	Person p1,p2;
	p1.age &#x3D; 333;
	p2.age &#x3D; 666;
    &#x2F;&#x2F;void 返回值的只能输出一次.
    &#x2F;&#x2F;cout&lt;&lt;p1;
    &#x2F;&#x2F;第二种可以连续输出
	cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; endl;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="++运算符重载"></a>++运算符重载</h4><h5 id="成员函数重载-2"><a href="#成员函数重载-2" class="headerlink" title="成员函数重载"></a>成员函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
	&#x2F;&#x2F;重载左++
	Person&amp; operator++()
	&#123;
		this-&gt;age++;
		return *this;
	&#125;
	&#x2F;&#x2F;重载右++
	&#x2F;&#x2F;怎么区分前置和后置？
	&#x2F;&#x2F;后置++的参数中多了一个int占位符来区分
	&#x2F;&#x2F;后置++要返回值，不能返回引用，因为tmp使用完就会被释放
	Person operator++(int)
	&#123;
		Person tmp;
		tmp &#x3D; *this;
		this-&gt;age++;
		return tmp;
	&#125;	
&#125;;
int main()
&#123;
	Person p1;
	p1.age &#x3D; 0;
	&#x2F;&#x2F;本质p1.operator++()
	++p1;
	p1++;
	cout &lt;&lt; p1.age &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="全局函数重载-2"><a href="#全局函数重载-2" class="headerlink" title="全局函数重载"></a>全局函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
   int age;
&#125;;

Person&amp; operator++(Person&amp; p1)
&#123;
	p1.age++;
	return p1;
&#125;

Person operator++(Person&amp; p1, int)
&#123;
	Person p2;
	p2 &#x3D; p1;
	p1.age++;
	return p2;
&#125;
int main()
&#123;
	Person p1;
	p1.age &#x3D; 5;
	&#x2F;&#x2F;本质p1.operator++()
	++p1;
	p1++;
	cout &lt;&lt; p1.age &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-运算符重载"><a href="#x3D-运算符重载" class="headerlink" title="&#x3D; 运算符重载"></a>&#x3D; 运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ul>
<li>1.默认构造函数</li>
<li>2.默认析构函数</li>
<li>3.默认拷贝构造函数</li>
<li>4.赋值运算符 ”operator&#x3D;“ 对属性进行值拷贝</li>
</ul>
<blockquote>
<p>c++提供的默认拷贝构造函数，和赋值运算符函数都是浅拷贝</p>
<p>如果类中有属性指向堆区，做赋值时也会出现深浅拷贝的问题</p>
</blockquote>
<h5 id="成员函数重载-3"><a href="#成员函数重载-3" class="headerlink" title="成员函数重载"></a>成员函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	&#x2F;&#x2F;构造函数
	Person(int a)
	&#123;
		&#x2F;&#x2F;堆区开的内存要用delete释放
		age &#x3D; new int(a);
	&#125;

	int* age;

	~Person()
	&#123;
		&#x2F;&#x2F;释放堆区内存
		delete age;
		age &#x3D; NULL;
	&#125;

	&#x2F;&#x2F;重载运算符
	Person&amp; operator&#x3D;(Person&amp; p1)
	&#123;
		&#x2F;&#x2F;先判断自身的属性有没有在堆区有内存
		if (age !&#x3D; NULL)
		&#123;
			delete age;
			age &#x3D; NULL;
		&#125;
		&#x2F;&#x2F;然后复制
		age &#x3D; new int(*p1.age);
		&#x2F;&#x2F;为了保证可以链式操作，所以返回自身引用
		return *this;
	&#125;
&#125;;
int main()
&#123;
	&#x2F;&#x2F;没有在析构中用delete释放，这段代码就没问题.
	&#x2F;&#x2F;但是释放了就会报错，因为堆区的内存被重复释放
	Person p1(10);
	Person p2(20);
	Person p3(30);
	&#x2F;&#x2F;本质是：p3.operator&#x3D;(p2.operator&#x3D;(p1))
	p3 &#x3D; p2 &#x3D; p1;
	cout &lt;&lt; *p1.age &lt;&lt; &quot;  &quot; &lt;&lt; *p2.age &lt;&lt;&quot;  &quot; &lt;&lt;*p3.age&lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="全局函数重载-3"><a href="#全局函数重载-3" class="headerlink" title="全局函数重载"></a>全局函数重载</h5><blockquote>
<p>&#x3D;运算符必须是成员函数</p>
</blockquote>
<h4 id="x3D-和-x3D-x3D-关系运算符重载"><a href="#x3D-和-x3D-x3D-关系运算符重载" class="headerlink" title="!&#x3D;和&#x3D;&#x3D; 关系运算符重载"></a>!&#x3D;和&#x3D;&#x3D; 关系运算符重载</h4><h5 id="成员函数重载-4"><a href="#成员函数重载-4" class="headerlink" title="成员函数重载"></a>成员函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
	bool operator&#x3D;&#x3D;(Person&amp; p1)
	&#123;
		if (this-&gt;age &#x3D;&#x3D; p1.age)
		&#123;
			return true;
		&#125;
		else
		&#123;
			return false;
		&#125;
	&#125;
&#125;;
int main()
&#123;
	Person p1;
	p1.age &#x3D; 10;
	Person p2;
	p2.age &#x3D; 10;
	if (p1 &#x3D;&#x3D; p2)
	&#123;
		cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;
	&#125;
	else
	&#123;
		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="全局函数重载-4"><a href="#全局函数重载-4" class="headerlink" title="全局函数重载"></a>全局函数重载</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
&#125;;
bool operator&#x3D;&#x3D;(Person&amp; p1,Person&amp; p2)
&#123;
	if (p1.age &#x3D;&#x3D; p2.age)
	&#123;
		return true;
	&#125;
	else
	&#123;
		return false;
	&#125;
&#125;
int main()
&#123;
	Person p1;
	p1.age &#x3D; 10;
	Person p2;
	p2.age &#x3D; 10;
	if (p1 &#x3D;&#x3D; p2)
	&#123;
		cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;
	&#125;
	else
	&#123;
		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul>
<li>函数调用运算符是<code>()</code></li>
<li>因为重载后的使用方式像在用函数，所以也称为仿函数</li>
<li>放函数没有固定写法，非常灵活</li>
<li>在以后的STL中会使用</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyPrint
&#123;
public:
	&#x2F;&#x2F;重载函数调用运算符
	void operator()(string str)
	&#123;
		cout &lt;&lt; str &lt;&lt; endl;
	&#125;
&#125;;
int main()
&#123;
	string str &#x3D; &quot;张三&quot;;
	MyPrint mp;
	mp.operator()(str);
	&#x2F;&#x2F;简化成
	mp(str);
    &#x2F;&#x2F;匿名对象调用
	MyPrint()(str);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的好处：减少代码的复用</p>
<h4 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h4><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928141645864.png"></p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928142410151.png"></p>
<h4 id="继承下来的东西"><a href="#继承下来的东西" class="headerlink" title="继承下来的东西"></a>继承下来的东西</h4><p>父类中所有非静态成员都会被继承下去（类中的函数和静态成员都不算类的大小）</p>
<p>父类中的私有成员属性，是被编译器隐藏了.所以访问不到，但是还是继承下去的.</p>
<h4 id="Vs开发人员命令提示工具查看类的继承"><a href="#Vs开发人员命令提示工具查看类的继承" class="headerlink" title="Vs开发人员命令提示工具查看类的继承"></a>Vs开发人员命令提示工具查看类的继承</h4><h5 id="1-在win开始菜单中找到vs自带的开发人员命令提示工具"><a href="#1-在win开始菜单中找到vs自带的开发人员命令提示工具" class="headerlink" title="1.在win开始菜单中找到vs自带的开发人员命令提示工具"></a>1.在win开始菜单中找到vs自带的开发人员命令提示工具</h5><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928153044931.png"></p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928153103932.png"></p>
<h5 id="2-找到当前文件的路径"><a href="#2-找到当前文件的路径" class="headerlink" title="2.找到当前文件的路径"></a>2.找到当前文件的路径</h5><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928153222429.png"></p>
<h5 id="3-cd到当前文件路径下"><a href="#3-cd到当前文件路径下" class="headerlink" title="3.cd到当前文件路径下"></a>3.cd到当前文件路径下</h5><p>打开所在文件夹后，复制文件路径</p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928153519144.png"></p>
<p>回到开发人员命令工具里用cd来到当前文件路径下</p>
<p><code>cd E:\Vs_studio_C++_Test\C++_Test1\C++_Test1</code></p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928153759174.png"></p>
<p>可以看到cd后的路径变了.</p>
<p>最后输入dir显示当前路径下的文件，看看是否有你写的.cpp文件</p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928154008420.png"></p>
<h5 id="4-输入指令查看类的对象模型"><a href="#4-输入指令查看类的对象模型" class="headerlink" title="4.输入指令查看类的对象模型"></a>4.输入指令查看类的对象模型</h5><p>指令为：</p>
<p><code>cl /d1 reportSingleClassLayoutSon &quot;test3.cpp&quot;</code></p>
<p>cpp文件名或者类名不同自行替换</p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928155235479.png"></p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928155324383.png"></p>
<h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>写好了类没有编译.直接查看布局.</p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928155442527.png"></p>
<h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>父类构造调用</p>
<p>子类构造调用</p>
<p>子类析构调用</p>
<p>父类析构调用</p>
<h4 id="继承同名成员处理和同名静态成员处理"><a href="#继承同名成员处理和同名静态成员处理" class="headerlink" title="继承同名成员处理和同名静态成员处理"></a>继承同名成员处理和同名静态成员处理</h4><h5 id="同名成员属性处理"><a href="#同名成员属性处理" class="headerlink" title="同名成员属性处理"></a>同名成员属性处理</h5><p>访问子类同名属性，直接调用就可以。因为默认优先使用子类的成员</p>
<p>调用父类的同名成员，需要加上父类的作用域.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base
&#123;
public:  
    int num;
&#125;;
class Son : public Base
&#123;
public:
    int num;
&#125;;
int main()
&#123;
    &#x2F;&#x2F;实例化对象
    Son s;
    &#x2F;&#x2F;默认访问子类的成员属性
    cout &lt;&lt; s.num &lt;&lt; endl;
    &#x2F;&#x2F;加上父类的作用域，就访问父类的成员属性
    cout &lt;&lt; s.Base::num &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="同名成员属性函数"><a href="#同名成员属性函数" class="headerlink" title="同名成员属性函数"></a>同名成员属性函数</h5><p>同名函数比同名属性多一个点</p>
<p>函数如果重载会怎么样？</p>
<p>结论，子类的函数重载，照样用。父类加作用域.</p>
<p>普通成员函数必须使用对象访问</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base
&#123;
public:  
    void func()
    &#123;
        ;
    &#125;
    &#x2F;&#x2F;父类中函数重载
    void func(int a)
    &#123;
        ;
    &#125;
&#125;;
class Son : public Base
&#123;
public:
    void func()
    &#123;
        ;
    &#125;
    &#x2F;&#x2F;子类中函数重载
    void func(int a)
    &#123;
        ;
    &#125;
&#125;;
int main()
&#123;
    &#x2F;&#x2F;实例化对象
    Son s;
    &#x2F;&#x2F;默认访问子类的成员函数
    s.func();
    &#x2F;&#x2F;加上父类的作用域，就可以调用父类的函数
    s.Base::func();
    &#x2F;&#x2F;子类的直接调用
    s.func(10);
    &#x2F;&#x2F;父类加作用域
    s.Base::func(10);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="静态同名属性处理"><a href="#静态同名属性处理" class="headerlink" title="静态同名属性处理"></a>静态同名属性处理</h5><p>首先回顾下静态成员：</p>
<ul>
<li>所有对象共享同一块数据，（如果一个类中修改了他，那么其他用到这个静态函数或者属性的类中的值也会一起变）</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
<li>等….</li>
</ul>
<blockquote>
<p>静态同名成员属性和普通同性成员属性的使用和规则是一样的.</p>
</blockquote>
<p>比普通不同的是，静态可以用类名访问</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    &#x2F;&#x2F;不需要实例化对象
    cout &lt;&lt; Son::age &lt;&lt; endl;
    &#x2F;&#x2F;访问父类的静态成员属性
    cout &lt;&lt; Son::Base::age &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928214549149.png"></p>
<h5 id="静态同名成员函数"><a href="#静态同名成员函数" class="headerlink" title="静态同名成员函数"></a>静态同名成员函数</h5><p>回顾一下静态成员函数：</p>
<ul>
<li>可以在类中定义</li>
<li>静态成员函数里只能用静态成员变量</li>
<li>所有对象共享同一块</li>
</ul>
<p>和普通成员函数不同的是静态成员函数可以使用类名访问</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    &#x2F;&#x2F;不需要实例化对象
    cout &lt;&lt; Son::func() &lt;&lt; endl;
    &#x2F;&#x2F;访问父类的静态成员属性
    cout &lt;&lt; Son::Base::func() &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果子类中出现了和父类同名的静态成员函数，那就会把父类的同名函数全盖住，不管父类是不是静态函数</p>
<p>重载的也会覆盖</p>
<p>想要调用，就加父类作用域</p>
</blockquote>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928215908783.png"></p>
<h5 id="多继承占用内存空间"><a href="#多继承占用内存空间" class="headerlink" title="多继承占用内存空间"></a>多继承占用内存空间</h5><p>自己的加上所有父类的大小</p>
<h5 id="多继承的调用"><a href="#多继承的调用" class="headerlink" title="多继承的调用"></a>多继承的调用</h5><p>和普通继承一样，优先使用子类，父类成员被覆盖。</p>
<p>想调用父类就要标注作用域</p>
<h5 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h5><p>什么是菱形继承？</p>
<p>类B继承了类A</p>
<p>类C继承了类A</p>
<p>类D继承了BC</p>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928222528949.png"></p>
<p>当有同名的成员属性的时候，就会出现二义性.那怎么解决呢？</p>
<p>使用虚继承</p>
<p>关键词virtual</p>
<p>在继承的时候加上关键字，变成虚继承</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;虚继承以后，这个类变成了虚基类
class A
&#123;
public:
	int age;

&#125;;
&#x2F;&#x2F;虚继承
class B:virtual public A
&#123;
	;
&#125;;
&#x2F;&#x2F;虚继承
class C:virtual public B
&#123;
	;
&#125;;
class D:public B,public C
&#123;
	;
&#125;;
    
int main()
&#123;
    D d;
    cout &lt;&lt; d.B::age &lt;&lt; endl;
    cout &lt;&lt; d.C::age &lt;&lt; endl;
    cout &lt;&lt; d.age &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928233541373.png"></p>
<blockquote>
<p>虚继承以后，D继承的不是BC的属性，而是BC的虚基类指针.</p>
<p>虚基类指针通过偏移量找到虚基类表</p>
<p>虚基类表中有唯一的一份数据.就解决了二义性的问题</p>
</blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220928234235438.png"></p>
<h5 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h5><ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前后期的维护和拓展</li>
</ul>
<h5 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h5><p>1.先让父类变成抽象类（虚基类）</p>
<ul>
<li>加虚函数（virtual），或者纯虚函数</li>
</ul>
<p>2.子类中重写父类中的所有抽象方法（虚函数）</p>
<ul>
<li>java中抽象类中的方法不能定义.c++中是虚函数可以定义，纯虚不能定义</li>
<li>c++有虚函数或者纯虚函数，类都会变成抽象类</li>
</ul>
<p>3.父类引用引用子类对象，</p>
<h5 id="多态的底层"><a href="#多态的底层" class="headerlink" title="多态的底层"></a>多态的底层</h5><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220929094648231.png"></p>
<h5 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h5><p>上面的例子用的是虚函数</p>
<p>可以发现，父类中的虚函数，就是定义了也不会调用他，而是直接被子类重写的函数覆盖掉</p>
<p>所以纯虚函数就诞生了</p>
<p>一个类中有纯虚函数，这个类就是抽象类</p>
<ul>
<li><p>抽象类不可以被实例化</p>
</li>
<li><p>抽象类中的函数不可以具体实现</p>
</li>
<li><p>抽象类就是为了被继承的，用于多态的操作</p>
</li>
<li><p>继承了抽象类的子类，必须重写抽象类中的所有纯虚函数.不然这个子类也变成抽象类</p>
</li>
</ul>
<h6 id="纯虚函数的使用"><a href="#纯虚函数的使用" class="headerlink" title="纯虚函数的使用"></a>纯虚函数的使用</h6><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220929110844056.png"></p>
<h5 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h5><h6 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h6><p>多态使用时，在子类中有属性开辟到堆区了，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>所以虚析构和纯虚析构就诞生了</p>
<ul>
<li>虚析构和纯虚析构都可以解决父类指针释放问题</li>
<li>都需要有具体的实现</li>
<li>不同的是，如果有纯虚析构，那这个类不能被实例化，这个类属于抽象类</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;抽象类
class A
&#123;
public:
    &#x2F;&#x2F;构造函数
    A()
    &#123;
        cout &lt;&lt; &quot;A的构造函数调用&quot; &lt;&lt; endl;
    &#125;
    &#x2F;&#x2F;纯虚函数
    virtual void func() &#x3D; 0;
    &#x2F;&#x2F;普通析构函数会导致子类的析构函数不被调用
    &#x2F;&#x2F;~A()
    &#x2F;&#x2F;&#123;
    &#x2F;&#x2F;    cout &lt;&lt; &quot;A的析构函数调用&quot; &lt;&lt; endl;
    &#x2F;&#x2F;&#125;
    
    &#x2F;&#x2F;使用虚析构，子类的析构函数就会被调用.就可以释放堆区的内存了
    virtual ~A()
    &#123;
        cout&lt;&lt;&quot;A的虚析构函数调用&quot;
    &#125;
&#125;;
class B :public A
&#123;
public:
    &#x2F;&#x2F;构造函数
    B(string name)
    &#123;
        cout &lt;&lt; &quot;B的构造函数调用&quot; &lt;&lt; endl;
        &#x2F;&#x2F;用new在构造函数中在堆区开内存存放数据
        this-&gt;name &#x3D; new string(name);
    &#125;
    &#x2F;&#x2F;重写父类纯虚函数
    void func()
    &#123;
        cout &lt;&lt; &quot;B的func函数&quot; &lt;&lt; endl;
    &#125;
    ~B()
    &#123;
        cout &lt;&lt; &quot;B的析构函数调用&quot; &lt;&lt; endl;
        if(this-&gt;name !&#x3D; NULL)
        &#123;
            delete name;
            name &#x3D; NULL;
        &#125;
    &#125;
    string* name;

&#125;;

int main()
&#123;
    &#x2F;&#x2F;父类引用，引用子类对象.发生多态.调用子类的构造函数
    A* a &#x3D; new B(&quot;张三&quot;);
    a-&gt;func();
    delete a;
    a &#x3D; NULL;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码的运行结果是：</p>
<p>A的构造函数调用<br>B的构造函数调用<br>B的func()函数<br>A的析构函数调用</p>
<p>可以看到，并没有调用B的析构函数，没有调用B的析构，那也就是说B里面new的那个string并没有释放</p>
<p>所以需要用虚析构，他就会调用B中的析构函数了</p>
<h6 id="纯虚析构"><a href="#纯虚析构" class="headerlink" title="纯虚析构"></a>纯虚析构</h6><p>需要类内声明</p>
<p>类外实现.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;抽象类
class A
&#123;
public:
    &#x2F;&#x2F;构造函数
    A()
    &#123;
        cout &lt;&lt; &quot;A的构造函数调用&quot; &lt;&lt; endl;
    &#125;
    &#x2F;&#x2F;纯虚函数
    virtual void func() &#x3D; 0;
    &#x2F;&#x2F;普通析构函数会导致子类的析构函数不被调用
    &#x2F;&#x2F;~A()
    &#x2F;&#x2F;&#123;
    &#x2F;&#x2F;    cout &lt;&lt; &quot;A的析构函数调用&quot; &lt;&lt; endl;
    &#x2F;&#x2F;&#125;
    
    &#x2F;&#x2F;使用虚析构，子类的析构函数就会被调用.就可以释放堆区的内存了
    &#x2F;&#x2F;virtual ~A()
    &#x2F;&#x2F;&#123;
    &#x2F;&#x2F;    cout&lt;&lt;&quot;A的虚析构函数调用&quot;
    &#x2F;&#x2F;&#125;
    
    &#x2F;&#x2F;和虚析构不同的地方就这里一个
    &#x2F;&#x2F;类内声明纯虚析构
    virtual ~A() &#x3D; 0;
&#125;;
&#x2F;&#x2F;类外来实现纯虚析构
A::~A()
&#123;
    cout&lt;&lt;&quot;A的虚析构调用&quot;&lt;&lt;endl;
&#125;

int main()
&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件操作5步走：</p>
<ul>
<li><p>1.包含头文件<code>#include&lt;fstream&gt;</code></p>
</li>
<li><p>2.创建流对象</p>
<ul>
<li>ofstream:写操作</li>
<li>ifstream:读操作</li>
<li>fstream:读写操作</li>
</ul>
</li>
<li><p>3.打开文件<code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p>
<ul>
<li>读文件时需要判断文件是否成功打开.</li>
</ul>
</li>
<li><p>4.写入数据<code>ofs&lt;&lt;&quot;写入的数据&quot;;</code></p>
</li>
<li><p>5.关闭文件<code>ofs.close();</code></p>
</li>
</ul>
<p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220929145600611.png"></p>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1.包含头文件
#include&lt;fstream&gt;
int main()
&#123;
	&#x2F;&#x2F;2.创建流对象
	ofstream ofs;
	&#x2F;&#x2F;3.打开文件
	ofs.open(&quot;test001.txt&quot;, ios::out);
	&#x2F;&#x2F;4.写入文件
	ofs &lt;&lt; &quot;zhangsan,18&quot; &lt;&lt; endl;
	ofs &lt;&lt; &quot;张三 18&quot; &lt;&lt; endl;
	ofs &lt;&lt; &quot;666&quot; &lt;&lt; endl;
	&#x2F;&#x2F;5.关闭文件
	ofs.close();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1.包含头文件#include&lt;fstream&gt;
&#x2F;&#x2F;2.创建流对象ifstream ifs;
&#x2F;&#x2F;3.打开文件ifs.open(&quot;文件路径&quot;，打开方式);
&#x2F;&#x2F;      并判断是否打开成功ifs.is_open();返回值是bool类型
&#x2F;&#x2F;4.读数据，4种读取方式
&#x2F;&#x2F;5.关闭文件ifs.close();
#include&lt;fstream&gt;
int main()
&#123;
	&#x2F;&#x2F;创建流对象
	ifstream ifs;
	&#x2F;&#x2F;打开文件
	ifs.open(&quot;test001.txt&quot;, ios::in);
	&#x2F;&#x2F;判断是否打开成功
	if (!ifs.is_open())
	&#123;
		cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
		return 0;
	&#125;
	&#x2F;&#x2F;读数据
	&#x2F;&#x2F;&#x2F;&#x2F;第一种方式：创建一个足够大的字符数组，用循环把文件中的数据读到数组中打印.
	&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;
	&#x2F;&#x2F;&#x2F;&#x2F;读不到数据了，就返回假，循环停止.
	&#x2F;&#x2F;while (ifs &gt;&gt; buf)
	&#x2F;&#x2F;&#123;
	&#x2F;&#x2F;	cout &lt;&lt; buf &lt;&lt; endl;;
	&#x2F;&#x2F;&#125;

	&#x2F;&#x2F;&#x2F;&#x2F;第二种方式:使用ifs提供的getline(读取的数据存放在哪里，最多读多少字节)函数，这个函数是获取一行的意思
	&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;
	&#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf)))
	&#x2F;&#x2F;&#123;
	&#x2F;&#x2F;	cout &lt;&lt; buf &lt;&lt; endl;
	&#x2F;&#x2F;&#125;

	&#x2F;&#x2F;&#x2F;&#x2F;第三种方式：使用字符串类型和getline函数，getline(基础输入流ifs,读取的数据存放的位置)
	&#x2F;&#x2F;string str;
	&#x2F;&#x2F;while (getline(ifs, str))
	&#x2F;&#x2F;&#123;
	&#x2F;&#x2F;	cout &lt;&lt; str &lt;&lt; endl;
	&#x2F;&#x2F;&#125;

	&#x2F;&#x2F;&#x2F;&#x2F;第四种方式：使用ifs提供的get函数一个一个读取，然后一个一个打印
	&#x2F;&#x2F;&#x2F;&#x2F;遇到空格、\0、回车符、endl等会导致打印的乱七八糟。读的还慢，不推荐这种.
	&#x2F;&#x2F;char ch;
	&#x2F;&#x2F;while ((ch &#x3D; ifs.get()) !&#x3D; EOF)
	&#x2F;&#x2F;&#123;
	&#x2F;&#x2F;	cout &lt;&lt; ch;
	&#x2F;&#x2F;&#125;

	&#x2F;&#x2F;关闭文件
	ifs.close();

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>函数模板的作用：</p>
<p>建立一个通用函数，其函数返回值和参数类型可以不确定，用一个虚拟的类型来代表</p>
<p>c++另一种编程思想叫<strong>泛型编程</strong>，主要利用的技术就是模板</p>
<p>c++提供了两种模板机制：函数模板和类模板</p>
<p>怎么查看T是什么类型的？</p>
<p>答：<code>typeid(T)</code></p>
<h3 id="函数模板的语法"><a href="#函数模板的语法" class="headerlink" title="函数模板的语法"></a>函数模板的语法</h3><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20220929163615842.png"></p>
<p>例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
T func(T t)
&#123;
    ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="函数模板的使用"><a href="#函数模板的使用" class="headerlink" title="函数模板的使用"></a>函数模板的使用</h3><p>自动类型推导，必须推导出一致的数据类型T，才可以使用</p>
<p>模板必须要确定出T的数据类型才能用</p>
<h5 id="1-自动类型推导"><a href="#1-自动类型推导" class="headerlink" title="1.自动类型推导"></a>1.自动类型推导</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板，这里用typename还是class不影响，都可以使用
template&lt;class T&gt;
&#x2F;&#x2F;因为要交换两个数，所以传引用
void my_Swap(T &amp;a, T &amp;b)
&#123;
	T tmp &#x3D; a;
	a &#x3D; b;
	b &#x3D; tmp;
&#125;
int main()
&#123;
	int a &#x3D; 10;
	int b &#x3D; 20;
	&#x2F;&#x2F;模板会根据你输入数据类型，自动推导出数据类型
	my_Swap(a, b);
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-显示指定类型"><a href="#2-显示指定类型" class="headerlink" title="2.显示指定类型"></a>2.显示指定类型</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    &#x2F;&#x2F;指定他T是什么数据类型
    my_Swap&lt;int&gt;(a,b);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>1.普通函数调用，可以发生隐式类型转化</p>
<ul>
<li>比如一个字符数据类型和一个整形相加，传到函数中会被当成整形计算，再通过返回值确定是返回字符还是整形.</li>
</ul>
<p>函数模板，用自动类型推导，不可以发生隐式类型转换</p>
<p>函数模板，用显示指定类型，可以发生隐式类型转换</p>
<h3 id="普通函数与函数模板的调用区别"><a href="#普通函数与函数模板的调用区别" class="headerlink" title="普通函数与函数模板的调用区别"></a>普通函数与函数模板的调用区别</h3><p>1.如果函数模板和普通函数都可以实现，优先调用普通函数</p>
<ul>
<li>如果说普通函数只有函数声明，而没有具体实现，那么编译器会直接报错，而不是去调用模板函数</li>
</ul>
<p>2.可以通过空模板参数列表来强制掉用函数模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    &#x2F;&#x2F;空模板参数列表
    func&lt;&gt;(int a,int b);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.函数模板也可以发生重载</p>
<p>4.如果函数模板可以产生更好的匹配，优先调用函数模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> &#x2F;&#x2F;普通函数
int func(int a, int b)
&#123;
	cout &lt;&lt; &quot;普通函数调用&quot; &lt;&lt; endl;
	return a + b;
&#125;
&#x2F;&#x2F;函数模板
template&lt;class T&gt;
void func(T a, T b)
&#123;
	cout &lt;&lt; &quot;函数模板调用&quot; &lt;&lt; endl;
&#125;

int main()
&#123;
	&#x2F;&#x2F;当参数和普通函数匹配，会优先调用普通函数
	int a &#x3D; 10;
	int b &#x3D; 20;
	func(10, 20);

	&#x2F;&#x2F;因为char类型传入普通函数，要发生隐式类型转换.
	&#x2F;&#x2F;而传入函数模板,只要推断出T是char类型就可以了，所以选择了调用函数模板
	char ch1 &#x3D; &#39;a&#39;;
	char ch2 &#x3D; &#39;b&#39;;
	func(ch1, ch2);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><p>当数据类型是自定义类型的时候，模板就会出问题.</p>
<p>代码写上去的时候不会报错，运行起来就会报错.</p>
<p>因为T是运行的时候才判断T是什么数据类型.</p>
<p>那怎么办呢？</p>
<p>答案是：利用具体化的模板，可以解决自定义类型的通用化</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person
&#123;
public:
	int age;
&#125;;
&#x2F;&#x2F;普通模板，传的是自定义类型就无法完成比较
template&lt;class T&gt;
bool func(T&amp; a, T&amp; b)
&#123;
	if (a &#x3D;&#x3D; b)
	&#123;
		return true;
	&#125;
	else
	&#123;
		return false;
	&#125;
&#125;
&#x2F;&#x2F;利用具体化模板，解决自定义类型的通用性
&#x2F;&#x2F;前面加上template&lt;&gt;就是模板具体化
template&lt;&gt; bool func(Person&amp; a, Person&amp; b)
&#123;
	if (a.age &#x3D;&#x3D; b.age)
	&#123;
		return true;
	&#125;
	else
	&#123;
		return false;
	&#125;
&#125;
int main()
&#123;
	int a &#x3D; 10;
	int b &#x3D; 10;
	&#x2F;&#x2F;调用的普通模板
	cout &lt;&lt; func(a, b) &lt;&lt; endl;
	Person p_a;
	p_a.age &#x3D; 20;
	Person p_b;
	p_b.age &#x3D; 20;
	&#x2F;&#x2F;调用的具体化模板
	cout &lt;&lt; func(p_a, p_b) &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h5 id="类模板的作用："><a href="#类模板的作用：" class="headerlink" title="类模板的作用："></a>类模板的作用：</h5><p>建立一个通用类，类中的数据成员，数据类型可以不具体确定.</p>
<h5 id="类模板的语法："><a href="#类模板的语法：" class="headerlink" title="类模板的语法："></a>类模板的语法：</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;type1和type2分别代表2种不同的数据类型
template&lt;class type1,class type2&gt;
class Person
&#123;
public:
	type1 age;
	type2 name;
&#125;;
int main()
&#123;
	&#x2F;&#x2F;错误：
	&#x2F;&#x2F;Person p;&#x2F;&#x2F;类模板没有自动类型推导
	
	&#x2F;&#x2F;正确：
	Person&lt;int,string&gt; p;&#x2F;&#x2F;告诉他你的type1和type2是什么类型

	p.age &#x3D; 10;
	p.name &#x3D; &quot;张三&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="类模板的使用："><a href="#类模板的使用：" class="headerlink" title="类模板的使用："></a>类模板的使用：</h5><p>1.类模板没有自动类型推导</p>
<p>2.类模板在模板参数列表中可以有默认参数类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;默认参数类型
template&lt;class type1 &#x3D; int, class type2 &#x3D; string&gt;
class Person
&#123;
public:
	type1 age;
	type2 name;
&#125;;
int main()
&#123;
	Person&lt;&gt; p;&#x2F;&#x2F;有默认参数类型就可以直接使用
	p.age &#x3D; 10;
	p.name &#x3D; &quot;张三&quot;;
	cout &lt;&lt; p.age &lt;&lt; endl;
	cout &lt;&lt; p.name &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="类模板中成员函数的创建时机"><a href="#类模板中成员函数的创建时机" class="headerlink" title="类模板中成员函数的创建时机"></a>类模板中成员函数的创建时机</h5><p>创建时机是：在调用时才去创建</p>
<p>什么意思？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;类模板中成员函数的调用时机
&#x2F;&#x2F;一个类模板中有两个成员函数
&#x2F;&#x2F;当你没有调用他的时候，他不会创建.调用了在创建
&#x2F;&#x2F;带来的问题就是：如果说两个成员函数中的数据类型不同，那么在写代码的时候不会报错，调用就报错
class Person1
&#123;
public:
    void p1_func()
    &#123;
        ;
    &#125;
&#125;;
class Person2
&#123;
public:
    void p2_func()
    &#123;
        ;
    &#125;
&#125;;

template&lt;class T&gt;
class Person
&#123;
public:
    &#x2F;&#x2F;实例化对象
    T obj;
    void func1()
    &#123;
        obj.p1_func();
    &#125;
    void func2()
    &#123;
        obj.p2_func();
    &#125;
&#125;;
int main()
&#123;
    &#x2F;&#x2F;类模板必须指定类型
    Person&lt;Person1&gt; p;
    &#x2F;&#x2F;单单这么写，编译器不会报错
    &#x2F;&#x2F;运行就报错.
    p.func1();
    p.func2();
    return 0;
    &#x2F;&#x2F;因为在确定模板T的数据类型时，只传过去Person1.
    &#x2F;&#x2F;而在模板中用到了Person2的函数，所以运行时会报错
    &#x2F;&#x2F;输入的时候不报错是因为，模板的函数只会在被调用的时候才去创建.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><h5 id="指定传入类型"><a href="#指定传入类型" class="headerlink" title="指定传入类型"></a>指定传入类型</h5><p>传参数的时候直接把数据类型清清楚楚写下函数里</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1.指定传入类型 
&#x2F;&#x2F;类模板
template&lt;class T1&gt;
class Person
&#123;
public:
	&#x2F;&#x2F;构造函数
	Person(int age)
	&#123;
		this-&gt;age &#x3D; age;
	&#125;
	&#x2F;&#x2F;类模板成员函数
	void showPerson()
	&#123;
		cout &lt;&lt; this-&gt;age &lt;&lt; endl;
	&#125;
	T1 age;
&#125;;
&#x2F;&#x2F;普通函数
&#x2F;&#x2F;类模板对象作为函数参数
void func(Person&lt;int&gt; &amp;p)
&#123;
	p.showPerson();
&#125;
int main()
&#123;
	&#x2F;&#x2F;正常实例化
	Person&lt;int&gt; p(10);
	&#x2F;&#x2F;正常调用
	p.showPerson();

	&#x2F;&#x2F;传入普通函数调用
	func(p);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="类的参数模板化"><a href="#类的参数模板化" class="headerlink" title="类的参数模板化"></a>类的参数模板化</h5><p>把普通函数的形参变成模板，传参的时候，然他自己推导参数是什么类型的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T1&gt;
class Person
&#123;
public:
	&#x2F;&#x2F;构造函数
	Person(int age)
	&#123;
		this-&gt;age &#x3D; age;
	&#125;
	&#x2F;&#x2F;类模板成员函数
	void showPerson()
	&#123;
		cout &lt;&lt; this-&gt;age &lt;&lt; endl;
	&#125;
	T1 age;
&#125;;
&#x2F;&#x2F;参数模板化
template&lt;class T1&gt;
void func(Person&lt;T1&gt;&amp; p)
&#123;
	p.showPerson();
&#125;
int main()
&#123;
	Person&lt;int&gt; p(10);
	func&lt;&gt;(p);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="整个类模板化"><a href="#整个类模板化" class="headerlink" title="整个类模板化"></a>整个类模板化</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;和参数模板化差不多，参数模板化是自动推导参数列表的数据类型
&#x2F;&#x2F;整个类模板化是：类和类的数据类型都自动推导
template&lt;class T&gt;
void func(T&amp; p)
&#123;
	p.showPerson();
&#125;
&#x2F;&#x2F;类模板
template&lt;class T1&gt;
class Person
&#123;
public:
	&#x2F;&#x2F;构造函数
	Person(int age)
	&#123;
		this-&gt;age &#x3D; age;
	&#125;
	&#x2F;&#x2F;类模板成员函数
	void showPerson()
	&#123;
		cout &lt;&lt; this-&gt;age &lt;&lt; endl;
	&#125;
	T1 age;
&#125;;
int main()
&#123;
	Person&lt;int&gt; p(10);
	func(p);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;父类模板化
template&lt;class T&gt;
class Base
&#123;
public:
	T age;
&#125;;
&#x2F;&#x2F;子类要继承模板父类，要指定父类的数据类型
&#x2F;&#x2F;但是这样父类的数据类型就只能是一种
class Son1 :public Base&lt;int&gt;
&#123;
public:
	int age;
&#125;;
&#x2F;&#x2F;为了灵活指定父类类型，可以这么写
template&lt;class T1,class T2&gt;
class Son2 :public Base&lt;T2&gt;
&#123;
public:
	T1 age;
&#125;;

int main()
&#123;
	&#x2F;&#x2F;类模板必须指定参数类型，函数模板可以自动推导
	Son1 s1;
	Son2&lt;int, int&gt; s2;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1.先定义一个类模板
template&lt;class T1,class T2&gt;
class Person
&#123;
public:
	&#x2F;&#x2F;2.构造函数在类内声明，类外初始化.普通成员函数也一样，这里就用构造函数举例子
	Person(T1 age, T2 name);

	T1 age;
	T2 name;
&#125;;
&#x2F;&#x2F;类外初始化
&#x2F;&#x2F;作用域+模板+函数定义
&#x2F;&#x2F;加上模板是因为没有模板的话作用域里的T1和T2就无法识别.
template&lt;class T1,class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 age, T2 name)
&#123;
	this-&gt;age &#x3D; age;
	this-&gt;name &#x3D; name;
&#125;
int main()
&#123;
	Person&lt;int ,string&gt; p(10,&quot;张三&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="类模板的分文件编写"><a href="#类模板的分文件编写" class="headerlink" title="类模板的分文件编写"></a>类模板的分文件编写</h4><p><img src="/2022/09/15/c-%E5%AD%A6%E4%B9%A0/image-20221019055415939.png"></p>
<p>最好的解决方案：创建一个后缀.hpp的文件，将类模板的声明和实现，写在一起.</p>
<h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><h5 id="全局函数类内实现"><a href="#全局函数类内实现" class="headerlink" title="全局函数类内实现"></a>全局函数类内实现</h5><p>直接在类内声明友元（friend）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;全局函数做友元
template&lt;class T&gt;
class Person
&#123;
	&#x2F;&#x2F;在没加friend之前，他被认为是Person类的私有成员函数
	&#x2F;&#x2F;加上friend以后，被认为是一个全局函数.
	&#x2F;&#x2F;全局函数可以直接调用，而成员函数需要实例化对象才能调用.
	friend void printPerson(Person&lt;T&gt; p)
	&#123;
		cout &lt;&lt; p.age;
	&#125;
public:
	&#x2F;&#x2F;构造函数
	Person(T age)
	&#123;
		this-&gt;age &#x3D; age;
	&#125;
private:
	&#x2F;&#x2F;私有成员变量
	T age;
&#125;;
int main()
&#123;
	&#x2F;&#x2F;创建对象
	Person&lt;int&gt; p(10);
	&#x2F;&#x2F;不需要对象直接调用
	printPerson(p);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="全局函数类外实现"><a href="#全局函数类外实现" class="headerlink" title="全局函数类外实现"></a>全局函数类外实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;声明Person类的存在
template&lt;class T&gt;
class Person;
&#x2F;&#x2F;类外实现全局函数
template&lt;class T&gt;
&#x2F;&#x2F;因为这里用到了Person类，所以要在前面声明Person类
void printPerson(Person&lt;T&gt; p)
&#123;
	cout &lt;&lt; p.age;
&#125;
template&lt;class T&gt;
class Person
&#123;
	&#x2F;&#x2F;类内声明全局函数做友元
	&#x2F;&#x2F;只作友元还不够，因为加上友元之后这里的printPerson被理解成一个全局函数
	&#x2F;&#x2F;但是外面实现的是一个模板函数.所以要加上空模板类型加以区分（&lt;&gt;）
	&#x2F;&#x2F;尖括号就是空模板类型.
	&#x2F;&#x2F;这样还是不行，需要将定义写在声明的前面才能识别到
	friend void printPerson&lt;&gt;(Person&lt;T&gt; p);
public:
	Person(T age)
	&#123;
		this-&gt;age &#x3D; age;
	&#125;
private:
	T age;
&#125;;
int main()
&#123;
	Person&lt;int&gt; p(10);
	printPerson(p);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">AKYCCCC</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://akycccc.github.io/2022/09/15/c-%E5%AD%A6%E4%B9%A0/">https://akycccc.github.io/2022/09/15/c-%E5%AD%A6%E4%B9%A0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">AKYCCCC</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/cPlusPlus%E5%AD%A6%E4%B9%A0/">
                                    <span class="chip bg-color">cPlusPlus学习</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/09/16/IDEA%E5%90%AF%E5%8A%A8%E7%9B%B4%E6%8E%A5%E6%98%AF%E8%BF%9B%E5%85%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="IDEA启动直接是进入项目，而不能选择项目">
                        
                        <span class="card-title">IDEA启动直接是进入项目，而不能选择项目</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/" class="post-category">
                                    疑难解答
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/07/31/Typroa-hexo-github%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%95%99%E7%A8%8B-%E5%B7%B2%E8%A7%A3%E5%86%B3%E4%B8%8A%E4%BC%A0%E5%90%8E%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="Typroa+hexo+github插入图片教程(已解决上传后无法显示图片的问题)">
                        
                        <span class="card-title">Typroa+hexo+github插入图片教程(已解决上传后无法显示图片的问题)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-31
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%8D%9A%E5%AE%A2/" class="post-category">
                                    博客
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%99%E7%A8%8B/">
                        <span class="chip bg-color">教程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2024</span>
            
            <a href="/about" target="_blank">AKYCCCC</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "5";
                        var startDate = "5";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/AKYCCCC/AKYCCCC.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:954660147@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=954660147" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 954660147" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
